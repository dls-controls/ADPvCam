import xml.dom.minidom
from iocbuilder import Substitution, AutoSubstitution, SetSimulation, Device, records, Architecture, IocDataStream
from iocbuilder.arginfo import *
from iocbuilder.modules.asyn import Asyn, AsynPort, AsynIP
from iocbuilder.modules.busy import Busy
#from iocbuilder.modules.mca import Mca, mca_template

__all__ = ['AreaDetector']

#############################
# Areadetector base classes #
#############################

NDDataTypes=["NDInt8", "NDUInt8", "NDInt16", "NDUInt16", "NDInt32",
                 "NDUInt32", "NDFloat32", "NDFloat64"]

class AreaDetector(Device):
    """Library dependencies for areaDetector"""
    Dependencies = (Asyn, Busy)
    if Architecture() == "win32-x86" or Architecture() == "windows-x64":
        usemagic = True
        if Architecture() == "win32-x86":
            # The Magic libraries for 32bit do not work with the DLS toolchain
            # MSVC2010. So we cant use them.
            usemagic = False
        usehdfdlls = True
        hdfdlls = ['zlib', 'szip', 'hdf5']
        hdfstatic = ['zlib', 'libszip', 'hdf5']
        magiclibs = ['CORE_RL_zlib_',
            'CORE_RL_xlib_', 'CORE_RL_wmf_', 'CORE_RL_ttf_', 'CORE_RL_tiff_',
            'CORE_RL_png_', 'CORE_RL_libxml_', 'CORE_RL_lcms_', 'CORE_RL_jpeg_',
            'CORE_RL_jp2_', 'CORE_RL_jbig_', 'CORE_RL_bzlib_',
            'CORE_RL_filters_', 'CORE_RL_coders_', 'CORE_RL_magick_',
            'CORE_RL_wand_', 'CORE_RL_Magick++_']
        LibFileList = ['NeXus', 'PvAPI']
        if usemagic:
            LibFileList += magiclibs
        else:
            LibFileList += ['jpeg', 'tiff']
        if usehdfdlls:
            LibFileList = hdfdlls + LibFileList
        else:
            LibFileList = hdfstatic + LibFileList
        SysLibFileList = ['Oleaut32', 'Gdi32']
    else:
        LibFileList = ['GraphicsMagick',
            'GraphicsMagickWand', 'GraphicsMagick++', 'PvAPI', 'sz', 'hdf5', 'NeXus', 'cbfad']
        SysLibFileList = ['freetype', 'Xext', 'bz2', 'png12', 'xml2',
            'X11', 'gomp', 'z', 'jpeg', 'tiff']
    LibFileList += ['netCDF', 'ADBase', 'NDPlugin']
    DbdFileList = ['ADSupport', 'NDPluginSupport']
    AutoInstantiate = True

#############################

class _ADBaseTemplate(AutoSubstitution):
    """Template containing the base records of any areaDetector driver"""
    TemplateFile = 'ADBase.template'

class _ADBase(AsynPort):
    """This Base class creates an ADBase.template and stores the arguments
    in __dict__. It is meant to be subclassed by any areaDetector driver
    and should not normally be instantiated directly"""
    # This the the Base template to use
    _BaseTemplate = _ADBaseTemplate
    # This is the template class to load
    _SpecificTemplate = None
    Dependencies = (AreaDetector,)

    def __init__(self, **args):
        # Init the asyn port class
        self.__super.__init__(args["PORT"])
        # Init the base class
        self.base = self._BaseTemplate(**filter_dict(args,
            self._BaseTemplate.ArgInfo.Names()))
        # Init the template class
        if self._SpecificTemplate:
            self.template = self._SpecificTemplate(**filter_dict(args,
                self._SpecificTemplate.ArgInfo.Names()))
            self.__dict__.update(self.template.args)
        # Update args
        self.__dict__.update(self.base.args)

    ArgInfo = _ADBaseTemplate.ArgInfo
    # This tells xmlbuilder to use PORT instead of name as the row ID
    UniqueName = "PORT"

#############################

class _NDPluginBaseTemplate(AutoSubstitution):
    """Template containing the base records of any areaDetector plugin"""
    TemplateFile = 'NDPluginBase.template'

class _NDPluginBase(_ADBase):
    """This Base class creates an NDPluginBase.template and stores the arguments
    in __dict__. It is meant to be subclassed by any areaDetector plugin
    and should not normally be instantiated directly"""
    # This the the Base template to use
    _BaseTemplate = _NDPluginBaseTemplate

    def __init__(self, QUEUE = 16, BLOCK = 0, **args):
        # Init the superclass (_ADBase)
        self.__super.__init__(**args)
        # Store the args
        self.Configure = self._SpecificTemplate.TemplateFile.split(".")[0] + "Configure"
        self.__dict__.update(locals())

    def Initialise(self):
        print '# %(Configure)s(portName, queueSize, '\
            'blockingCallbacks, NDArrayPort, NDArrayAddr)' % self.__dict__
        print '%(Configure)s("%(PORT)s", %(QUEUE)d, ' \
            '%(BLOCK)d, "%(NDARRAY_PORT)s", %(NDARRAY_ADDR)s)' % self.__dict__

    # __init__ arguments
    ArgInfo = _NDPluginBaseTemplate.ArgInfo + makeArgInfo(__init__,
        QUEUE = Simple('Input array queue size', int),
        BLOCK = Simple('Blocking callbacks?', int))
    # Override NDARRAY_PORT to be any _ADBase subclass
    ArgInfo.descriptions["NDARRAY_PORT"] = Ident("Input Array Port", _ADBase)

#############################

class _NDFile(AutoSubstitution):
    """Template containing the records of an areaDetector file writing plugin"""
    TemplateFile = 'NDFile.template'
    SubstitutionOverwrites = [_NDPluginBaseTemplate, _ADBaseTemplate]

class _NDFileBase(_NDPluginBase):
    """This plugin creates an instance of _NDPluginBase, _NDFile, and
    _SpecificTemplate. It is meant to be subclassed by any areaDetector file
    writing plugin and should not normally be instantiated directly"""

    def __init__(self, **args):
        # Init the superclass (_NDPluginBase)
        self.__super.__init__(**args)
        # Init the file writing class
        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
        self.__dict__.update(self.file.args)

#############################

class _NDPluginProducerBase(_NDPluginBase):
    """This plugin creates an NDPluginBase that produces NDArrays. It is meant 
    to be subclassed by any areaDetector plugin that produces NDArrays and 
    should not normally be instantiated directly"""

    def __init__(self, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass (_NDPluginBase)
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    def Initialise(self):
        print '# %(Configure)s(portName, queueSize, '\
            'blockingCallbacks, NDArrayPort, NDArrayAddr, maxBuffers, ' \
            'maxMemory)' % self.__dict__
        print '%(Configure)s("%(PORT)s", %(QUEUE)d, ' \
            '%(BLOCK)d, "%(NDARRAY_PORT)s", %(NDARRAY_ADDR)s, %(BUFFERS)d, ' \
            '%(MEMORY)d)' % self.__dict__

    # __init__ arguments
    ArgInfo = _NDPluginBase.ArgInfo + makeArgInfo(__init__,
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

########################
# Areadetector drivers #
########################

'''
class _adsc(AutoSubstitution):
    TemplateFile="adsc.template"
    SubstitutionOverwrites = [_NDFile]

class adsc(_ADBase):
    """Creates an adsc areaDetector driver"""
    _SpecificTemplate = _adsc
    def __init__(self, modelName, **args):
        # Init the superclass
        self.__super.__init__(**args)
        # Init the file writing class
        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
        self.__dict__.update(self.file.args)
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _NDFile.ArgInfo + \
            _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        modelName = Choice('ADSC model name', 
            ["Q4", "Q4r", "Q210", "Q210r", "Q270", "Q315", "Q315r"]))            

    # Device attributes
    LibFileList = ['adsc']
    DbdFileList = ['adscSupport']

    def Initialise(self):
        print '# adscConfig(portName, modelName)'
        print 'adscConfig("%(PORT)s", "%(modelName)s")' % self.__dict__

def adsc_sim(**kwargs):
    return simDetector(2500, 2000, **kwargs)

SetSimulation(adsc, adsc_sim)
'''

#############################

class _mar345(AutoSubstitution):
    TemplateFile = "mar345.template"
    SubstitutionOverwrites = [_NDFile]

class mar345(_ADBase):
    """Creates a mar345 areaDetector driver"""
    _SpecificTemplate = _mar345
    def __init__(self, MARSERVER = "localhost:5001", BUFFERS = 50, MEMORY = 0, **args):
        # Make an asyn IP port to talk to mar345dtb on
        args["MARSERVER_PORT"] = args["PORT"] + "ip"
        self.ip = AsynIP(MARSERVER, name = args["MARSERVER_PORT"],
            input_eos = "\n", output_eos = "\n")
        # Init the superclass
        self.__super.__init__(**args)
        # Init the file writing class
        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
        self.__dict__.update(self.file.args)
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _NDFile.ArgInfo + \
            _SpecificTemplate.ArgInfo.filtered(without = ["MARSERVER_PORT"]) + \
            makeArgInfo(__init__,
        MARSERVER = Simple('Machine:port that mar345dtb is running on', str),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['mar345']
    DbdFileList = ['mar345Support']

    def Initialise(self):
        print '# mar345Config(portName, serverPort, maxBuffers, ' \
            'maxMemory)'
        print 'mar345Config("%(PORT)s", "%(MARSERVER_PORT)s", %(BUFFERS)d, ' \
            '%(MEMORY)d)' % self.__dict__

def mar345_sim(**kwargs):
    return simDetector(2500, 2000, **kwargs)

SetSimulation(mar345, mar345_sim)

#############################

class _perkinElmer(AutoSubstitution):
    TemplateFile = "PerkinElmer.template"
    #SubstitutionOverwrites = [_NDFile]

class perkinElmer(_ADBase):
    """Creates a Perkin Elmer areaDetector driver"""
    _SpecificTemplate = _perkinElmer
    def __init__(self, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + \
            _SpecificTemplate.ArgInfo + \
            makeArgInfo(__init__,
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['PerkinElmer','XISL']
    DbdFileList = ['PerkinElmerSupport']

    # Copy the libraries
    MakefileStringList = [ \
        'USR_CFLAGS=   /DWINVER=0x0502 /D_WIN32_WINNT=0x0502 /D_WIN32_WINDOWS=0x0502',
        'USR_CXXFLAGS=   /DWINVER=0x0502 /D_WIN32_WINNT=0x0502 /D_WIN32_WINDOWS=0x0502',
        'USR_CPPFLAGS=   /DWINVER=0x0502 /D_WIN32_WINNT=0x0502 /D_WIN32_WINDOWS=0x0502',
        'BIN_INSTALLS_WIN32 += $(AREADETECTOR)/ADApp/perkinElmerSupport/os/windows-x64/msvcr100.dll']
        #'BIN_INSTALLS_WIN32 += $(AREADETECTOR)/bin/$(T_A)/msvcr100.dll']


    def Initialise(self):
        print '#PerkinElmerConfig(const char *portName, int IDType, const char* IDValue, \
            int maxBuffers, size_t maxMemory, int priority, int stackSize )'
        print 'PerkinElmerConfig("%(PORT)s", 0, "", %(BUFFERS)d, ' \
            '%(MEMORY)d, 0, 0)' % self.__dict__

def perkinElmer_sim(**kwargs):
    return simDetector(2500, 2000, **kwargs)

SetSimulation(perkinElmer, perkinElmer_sim)

#############################

class _pvCam(AutoSubstitution):
    TemplateFile = "pvCam.template"
    #SubstitutionOverwrites = [_NDFile]

class pvCam(_ADBase):
    """Creates a pvCam areaDetector driver"""
    _SpecificTemplate = _pvCam
    def __init__(self, MAXSIZEX=2048, MAXSIZEY=2048, DATATYPE=3, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + \
            _SpecificTemplate.ArgInfo + \
            makeArgInfo(__init__,
        MAXSIZEX = Simple("Maximum image size in X"),
        MAXSIZEY = Simple("Maximum image size in Y"),        
        DATATYPE = Enum('Datatype', NDDataTypes),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['pvCam','pvcam32', 'pv_icl32']
    DbdFileList = ['pvCamSupport']

    # Copy the libraries
    MakefileStringList = [ \
        'USR_CFLAGS   += -DWIN32',
        'USR_CXXFLAGS += -DWIN32']

    def Initialise(self):
        print "# pvCamConfig(const char *portName, int maxSizeX, int maxSizeY, int dataType, int maxBuffers, size_t maxMemory)"
        print 'pvCamConfig("%(PORT)s", %(MAXSIZEX)d, %(MAXSIZEY)d, %(DATATYPE)d, %(BUFFERS)d, %(MEMORY)d)' % self.__dict__

def pvCam_sim(**kwargs):
    return simDetector(**kwargs)

SetSimulation(pvCam, pvCam_sim)

#############################

class _marCCD(AutoSubstitution):
    TemplateFile = "marCCD.template"
    SubstitutionOverwrites = [_NDFile]

class marCCD(_ADBase):
    """Creates a marCCD areaDetector driver"""
    _SpecificTemplate = _marCCD
    def __init__(self, MARSERVER = "localhost:2222", BUFFERS = 50, MEMORY = 0, **args):
        # Make an asyn IP port to talk to marCCDdtb on
        args["MARSERVER_PORT"] = args["PORT"] + "ip"
        self.ip = AsynIP(MARSERVER, name = args["MARSERVER_PORT"],
            input_eos = "\n", output_eos = "\n")
        # Init the superclass
        self.__super.__init__(**args)
        # Init the file writing class
        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
        self.__dict__.update(self.file.args)
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _NDFile.ArgInfo + \
            _SpecificTemplate.ArgInfo.filtered(without = ["MARSERVER_PORT"]) + \
            makeArgInfo(__init__,
        MARSERVER = Simple('Machine:port that marccd_server_socket is running on', str),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['marCCD_AD']
    DbdFileList = ['marCCD_ADSupport']

    def Initialise(self):
        print '# marCCDConfig(portName, serverPort, maxBuffers, ' \
            'maxMemory)'
        print 'marCCDConfig("%(PORT)s", "%(MARSERVER_PORT)s", %(BUFFERS)d, ' \
            '%(MEMORY)d)' % self.__dict__

def marCCD_sim(**kwargs):
    return simDetector(2500, 2000, **kwargs)

SetSimulation(marCCD, marCCD_sim)

#############################

#############################

class _andor3(AutoSubstitution):
    TemplateFile = "andor3.template"
##    SubstitutionOverwrites = [_NDFile]

class Andor3SpecificMustBeLoadedFirst(Device):
    """Library dependencies for areaDetector"""
    LibFileList = ['andor3']
    AutoInstantiate = True

class andor3(_ADBase):
    """Creates a andorCCD camera areaDetector driver"""
    _SpecificTemplate = _andor3
    def __init__(self, BUFFERS = 50, MEMORY = 0, CAMERA_ID = 0, PRIORITY = 0, STACKSIZE = 100000, MAX_FRAMES = 10, **args):

        # Init the superclass
        self.__super.__init__(**args)
        # Init the file writing class
##        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
##        self.__dict__.update(self.file.args)
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _NDFile.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int),
        CAMERA_ID = Simple('Camera identifier', int),
        MAX_FRAMES = Simple('''Max Frames - the number of frame buffers the driver queues to the SDK when acquiring data. 
The default value is 10. Increasing this number will allow the SDK to transfer images from the camera at the full 
interface speed even when the driver is not reading them that quickly. This will help to prevent frames from filling the 
camera RAM when operating close to the maximum interface transfer rate''', int),
        PRIORITY = Simple('The thread priority for the asyn port driver thread', int),
        STACKSIZE = Simple('The stack size for the asyn port driver thread', int))

    # Device attributes
    epics_host_arch = Architecture()
    if epics_host_arch.find('win') >= 0:
        LibFileList = ['andor3','atcorem']
    else:
        LibFileList = ['andor3','atcore']    
    
    DbdFileList = ['andor3Support']

    def Initialise(self):
        print '# andor3Config(portName, cameraID, maxBuffers, maxMemory, priority, stackSize, maxFrames)'
        print 'andor3Config("%(PORT)s", "%(CAMERA_ID)d", %(BUFFERS)d, %(MEMORY)d, %(PRIORITY)d, %(STACKSIZE)d, "%(MAX_FRAMES)d")' \
            % self.__dict__

andor3.Dependencies = (Andor3SpecificMustBeLoadedFirst, AreaDetector)

def andor3_sim(**kwargs):
    return simDetector(1004, 1004, **kwargs)

SetSimulation(andor3, andor3_sim)

#############################

#############################

class _andorCCD(AutoSubstitution):
#    TemplateFile = "andorCCD.template"
#    SubstitutionOverwrites = [_ADBaseTemplate]
    TemplateFile = "andorCCD.template"
    SubstitutionOverwrites = [_NDFile]

class AndorSpecificMustBeLoadedFirst(Device):
    """Library dependencies for areaDetector"""
    LibFileList = ['andor']
    AutoInstantiate = True

class andorCCD(_ADBase):
    """Creates a andorCCD camera areaDetector driver"""
    _SpecificTemplate = _andorCCD
    def __init__(self, BUFFERS = 50, MEMORY = 0, INSTALLPATH = "", PRIORITY = 0, STACKSIZE = 100000, **args):
        print "*****************************************************"
        print "WARNING - your builder generated andor IOC may not work!"
        print " Currently it is necessary to modify the generated iocs src/makefile to ensure the following link order:"
        print " BLxxI-EA-IOC-01_LIBS += ADBase, BLxxI-EA-IOC-01_LIBS += andor, BLxxI-EA-IOC-01_LIBS += GraphicsMagick"
        print " If you are using a plugin that requires GraphicsMagick (eg URLDriver or NDFileMagick) then it may not work."
        print " There is a conflict with a SetImage() function exisiting in both the andor and GraphicsMagick libraries"
        print " See note in areaDetector/etc/builder.py regarding linking the andor library for more info."
        print "*****************************************************"    
        # Init the superclass
        self.__super.__init__(**args)
        # Init the file writing class
        self.file = _NDFile(**filter_dict(args, _NDFile.ArgInfo.Names()))
        # Store the args
        self.__dict__.update(self.file.args)
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _NDFile.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int),
        INSTALLPATH = Simple('The path to the Andor directory containing the detector INI files, etc.'
            'This can be specified as an empty string ("") for new detectors that do not use the INI'
            'files on Windows, but must be a valid path on Linux (probably /usr/local/etc/andor).', str),
        PRIORITY = Simple('The thread priority for the asyn port driver thread', int),
        STACKSIZE = Simple('The stack size for the asyn port driver thread', int))

    # Device attributes
    LibFileList = ['andorCCD']
    DbdFileList = ['andorCCDSupport']

    def Initialise(self):
        print '# andorCCDConfig(portName, maxBuffers, maxMemory, installPath, priority, stackSize)'
        print 'andorCCDConfig("%(PORT)s", %(BUFFERS)d, %(MEMORY)d, "%(INSTALLPATH)s", %(PRIORITY)d, %(STACKSIZE)d)' \
            % self.__dict__

# ModuleBase.__AggregateDependencies unhelpfully puts AreaDetector and its Dependencies first on the list as _ADBase is a subclass of andorCCD.
# Override this behaviour and set the Dependencies to what we think they should actually be
andorCCD.Dependencies = (AndorSpecificMustBeLoadedFirst, AreaDetector)

# NB1 The 2-96 verion of libandor includes definitions for TiXmlDocument::LoadFile which conflicts with the exisiting TiXmlDocument library
# already in areadDetector. Andor need to remove this from their library exports until that happens we must link libandor after ADBase
# (ie BL08I-EA-IOC-01_LIBS += ADBase must be before BL08I-EA-IOC-01_LIBS += andor in the ioc src/makefile)
# The above hack performs this re-ordering.

# NB2 The andor library includes a definition for function SetImage. Unfortunately GraphicsMagik also includes a SetImage funtion which conflicts.
# For andor to work we need to load libandor before the GraphicsMajic library. This may break something; possibly the URL loading plugin or one  the file save plugins?
# (ie. BL08I-EA-IOC-01_LIBS += andor must be before BL08I-EA-IOC-01_LIBS += GraphicsMagick in the ioc src/makefile
# The above hack DOES NOT DO THIS RE-ORDERING.

def andorCCD_sim(**kwargs):
    return simDetector(1004, 1004, **kwargs)

SetSimulation(andorCCD, andorCCD_sim)

#############################

class _prosilica(AutoSubstitution):
    TemplateFile = "prosilica.template"
    SubstitutionOverwrites = [_ADBaseTemplate]

class prosilica(_ADBase):
    """Creates a prosilica camera areaDetector driver"""
    _SpecificTemplate = _prosilica
    def __init__(self, ID, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        ID = Simple('Unique ID for this camera', str),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['prosilica']
    DbdFileList = ['prosilicaSupport']

    def Initialise(self):
        print '# prosilicaConfig(portName, uniqueId, maxBuffers, maxMemory)'
        print 'prosilicaConfig("%(PORT)s", %(ID)s, %(BUFFERS)d, %(MEMORY)d)' \
            % self.__dict__

def prosilica_sim(**kwargs):
    return simDetector(1024, 768, **kwargs)

SetSimulation(prosilica, prosilica_sim)

#############################

class _simDetector(AutoSubstitution):
    TemplateFile = "simDetector.template"

class simDetector(_ADBase):
    """Creates a simulation detector"""
    _SpecificTemplate = _simDetector
    def __init__(self, WIDTH, HEIGHT, DATATYPE = 1, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass (_ADBase)
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        WIDTH = Simple('Image Width', int),
        HEIGHT = Simple('Image Height', int),
        DATATYPE = Enum('Datatype', NDDataTypes),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['simDetector']
    DbdFileList = ['simDetectorSupport']

    def Initialise(self):
        print '# simDetectorConfig(portName, maxSizeX, maxSizeY, dataType, ' \
            'maxBuffers, maxMemory)'
        print 'simDetectorConfig("%(PORT)s", %(WIDTH)s, %(HEIGHT)s, %(DATATYPE)d, ' \
            '%(BUFFERS)d, %(MEMORY)d)' % self.__dict__

#############################

class _URLDriver(AutoSubstitution):
    TemplateFile = "URLDriver.template"

class URLDriver(_ADBase):
    """Creates a URLDriver areaDetector driver"""
    _SpecificTemplate = _URLDriver
    def __init__(self, BUFFERS = 50, MEMORY = 0, **args):
        # Init the superclass
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    # __init__ arguments
    ArgInfo = _ADBase.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(__init__,
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
            'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    # Device attributes
    LibFileList = ['URLDriver']
    DbdFileList = ['URLDriverSupport']

    def Initialise(self):
        print '# URLDriverConfig(portName, maxBuffers, maxMemory)'
        print 'URLDriverConfig("%(PORT)s", %(BUFFERS)d, %(MEMORY)d)' % self.__dict__

def URLDriver_sim(**kwargs):
    return simDetector(1024, 768, **kwargs)

SetSimulation(URLDriver, URLDriver_sim)

#############################

class _PSL(AutoSubstitution):
    TemplateFile = "PSL.template"

class PSL(_ADBase):
    _SpecificTemplate = _PSL
    def __init__(self, IP_PORT, BUFFERS=50, MEMORY=0, **args):
        self.ip_port = AsynIP(IP_PORT, name=args["PORT"] + ".ip")
        self.__super.__init__(**args)
        self.__dict__.update(locals())

    ArgInfo = _ADBase.ArgInfo + _SpecificTemplate.ArgInfo + makeArgInfo(
        __init__,
        IP_PORT = Simple('Address and port of the PSL box', str),
        BUFFERS = Simple('Maximum number of NDArray buffers to be created for '
                         'plugin callbacks', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
                        'for driver and all attached plugins', int))
    LibFileList = ['PSL']
    DbdFileList = ['PSLSupport']

    def Initialise(self):
        print('# PSLConfig(portName, serverPort, maxBuffers, maxMemory)\n'
              'PSLConfig("{PORT}", "{PORT}.ip", {BUFFERS}, {MEMORY})'.format(
                  **self.__dict__))

########################
# Areadetector plugins #
########################

class _NDStdArrays(AutoSubstitution):
    """Template containing the records for an NDStdArray"""
    TemplateFile = 'NDStdArrays.template'

class NDStdArrays(_NDPluginBase):
    """This plugin provides a waveform record that can display the NDArrays
    produced by its NDARRAY_PORT"""
    _SpecificTemplate = _NDStdArrays
    def __init__(self, QUEUE = 2, MEMORY = 0, **args):
        # Init the superclass (_NDPluginBase)
        self.__super.__init__(**args)
        # Store the args
        self.__dict__.update(locals())

    def Initialise(self):
        print '# NDStdArraysConfigure(portName, queueSize, blockingCallbacks, '\
            'NDArrayPort, NDArrayAddr, maxMemory)'
        print 'NDStdArraysConfigure("%(PORT)s", %(QUEUE)d, %(BLOCK)d, ' \
            '"%(NDARRAY_PORT)s", %(NDARRAY_ADDR)s, %(MEMORY)d)' % self.__dict__

    # __init__ arguments
    # NOTE: _NDPluginBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _NDStdArrays.ArgInfo + _NDPluginBase.ArgInfo + makeArgInfo(__init__,
        QUEUE = Simple('Input array queue size', int),
        MEMORY = Simple('Max memory to allocate, should be maxw*maxh*nbuffer '
            'for driver and all attached plugins', int))

    ArgInfo.descriptions["FTVL"] = records.waveform.FieldInfo()["FTVL"]

#############################

class _NDFileNetCDF(AutoSubstitution):
    TemplateFile = 'NDFileNetCDF.template'
    SubstitutionOverwrites = [_NDFile]

class NDFileNetCDF(_NDFileBase):
    """This plugin can compress NDArrays to NetCDF and write them to file"""
    _SpecificTemplate = _NDFileNetCDF
    # NOTE: _NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

#############################

class _NDFileTIFF(AutoSubstitution):
    TemplateFile = 'NDFileTIFF.template'
    SubstitutionOverwrites = [_NDFile]

class NDFileTIFF(_NDFileBase):
    """This plugin can compress NDArrays to TIFF and write them to file"""
    _SpecificTemplate = _NDFileTIFF
    # NOTE: _NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

#############################

class _NDFileJPEG(AutoSubstitution):
    TemplateFile = 'NDFileJPEG.template'
    SubstitutionOverwrites = [_NDFile]

class NDFileJPEG(_NDFileBase):
    """This plugin can compress NDArrays to JPEG and write them to file"""
    _SpecificTemplate = _NDFileJPEG
    # NOTE: NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

#############################

#class _NDFileNexus(AutoSubstitution):
#    TemplateFile = 'NDFileNexus.template'
#    SubstitutionOverwrites = [_NDFile]

#class NDFileNexus(_NDFileBase):
#    """This plugin can compress NDArrays to Nexus and write them to file"""
#    _SpecificTemplate = _NDFileNexus
#    # NOTE: _NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
#    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

class _NDFileHDF5(AutoSubstitution):
    TemplateFile = 'NDFileHDF5.template'
    SubstitutionOverwrites = [_NDFile]

class NDFileHDF5(_NDFileBase):
    """This plugin can compress NDArrays to HDF5 and write them to file"""
    _SpecificTemplate = _NDFileHDF5
    # NOTE: _NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

#############################

class _NDFileMagick(AutoSubstitution):
    TemplateFile = 'NDFileMagick.template'
    SubstitutionOverwrites = [_NDFile]

class NDFileMagick(_NDFileBase):
    """This plugin can compress NDArrays to a range of formats supported by
    graphics magick and write them to file"""
    _SpecificTemplate = _NDFileMagick
    # NOTE: _NDFileBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDFileBase.ArgInfo

#############################

class _NDROI(AutoSubstitution):
    """Template containing the records for an NDROI"""
    TemplateFile = 'NDROI.template'

class NDROI(_NDPluginProducerBase):
    """This plugin selects a region of interest and optionally scales it to
    fit in a particular data type"""
    _SpecificTemplate = _NDROI
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDPluginProducerBase.ArgInfo

#############################

class _NDProcess(AutoSubstitution):
    """Template containing the records for an NDProcess"""
    TemplateFile = 'NDProcess.template'

class NDProcess(_NDPluginProducerBase):
    """This plugin does image processing like flat field correction, background
    subtraction, and recursive filtering"""
    _SpecificTemplate = _NDProcess
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDPluginProducerBase.ArgInfo

#############################

class _NDStats(AutoSubstitution):
    """Template containing the records for an NDStats"""
    TemplateFile = 'NDStats.template'

class NDStats(_NDPluginProducerBase):
    """This plugin calculates statistics like X and Y profile, centroid, and
    plots a histogram of binned pixels"""
    def __init__(self, **args):
        self.__super.__init__(**args)
        # Table of statistics parameters, tuple of:
        # (database name, attribute name, datatype, description)
        statsparams = [("COMPUTE_STATISTICS", "StatsComputeStats", "INT",    "Statistics: enable statistics computation"),
                       ("MIN_VALUE",          "StatsMin",          "DOUBLE", "Statistics: minimum value"),
                       ("MIN_X",              "StatsMinX",         "DOUBLE", "Statistics: minimum value X position"),
                       ("MIN_Y",              "StatsMinY",         "DOUBLE", "Statistics: minimum value Y position"),
                       ("MAX_VALUE",          "StatsMax",          "DOUBLE", "Statistics: maximum value"),
                       ("MAX_X",              "StatsMaxX",         "DOUBLE", "Statistics: maximum value X position"),
                       ("MAX_Y",              "StatsMaxY",         "DOUBLE", "Statistics: maximum value Y position"),
                       ("MEAN_VALUE",         "StatsMean",         "DOUBLE", "Statistics: mean value"),
                       ("SIGMA_VALUE",        "StatsSigma",        "DOUBLE", "Statistics: sigma value"),
                       ("TOTAL",              "StatsTotal",        "DOUBLE", "Statistics: total sum of all elements"),
                       ("NET",                "StatsNet",          "DOUBLE", "Statistics: sum of all elements minus background"),
                       ("BGD_WIDTH",          "StatsNetBgd",       "INT",    "Statistics: net background subtraction value"),
                       
                       ("COMPUTE_CENTROID",   "StatsComputeCentroid",   "INT",    "Statistics: enable centroid computation"),
                       ("CENTROID_THRESHOLD", "StatsCentroidThreshold", "DOUBLE", "Statistics: centroid threshold"),
                       ("CENTROIDX_VALUE",    "StatsCentroidX",         "DOUBLE", "Statistics: centroid X position"),
                       ("CENTROIDY_VALUE",    "StatsCentroidY",         "DOUBLE", "Statistics: centroid Y position"),
                       ("SIGMAX_VALUE",       "StatsCentroidSigmaX",    "DOUBLE", "Statistics: centroid sigma X"),
                       ("SIGMAY_VALUE",       "StatsCentroidSigmaY",    "DOUBLE", "Statistics: centroid sigma Y"),
                       ("SIGMAXY_VALUE",      "StatsCentroidSigmaXY",   "DOUBLE", "Statistics: centroid sigma XY") ]
        for (dbname, attrname, dtype, desc) in statsparams:
            NDAttributes(port=self, 
                         source=dbname, attrname=attrname, 
                         type="PARAM", datatype=dtype, 
                         description=desc)
    _SpecificTemplate = _NDStats
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDPluginProducerBase.ArgInfo

#############################

class _NDTransform(AutoSubstitution):
    """Template containing the records for an NDTransform"""
    TemplateFile = 'NDTransform.template'

class NDTransform(_NDPluginProducerBase):
    """This plugin selects a region of interest and optionally scales it to
    fit in a particular data type"""
    _SpecificTemplate = _NDTransform
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDPluginProducerBase.ArgInfo

#############################

class _NDOverlay(AutoSubstitution):
    """Template containing the records for an NDOverlay"""
    TemplateFile = 'NDOverlay.template'

class _NDOverlayN(AutoSubstitution):
    """Template containing the records for an NDOverlay"""
    TemplateFile = 'NDOverlayN.template'

class NDOverlay(_NDPluginProducerBase):
    """This plugin writes overlays on the array, like cursors and boxes"""
    _SpecificTemplate = _NDOverlay
    NOverlays = 8
    def __init__(self, MEMORY = 0, **args):
        # Init the superclass (_NDPluginBase)
        self.__super.__init__(**args)
        # Create some overlays
        for i in range(self.NOverlays):
            _NDOverlayN(P = args["P"], O = args["R"], R = "%s%d:" % (args["R"], i + 1),
                NAME = "Overlay %d" % (i + 1), SHAPE = 1, XPOS = "", YPOS = "", XSIZE = "",
                YSIZE = "", PORT = args["PORT"], ADDR = i, TIMEOUT = args["TIMEOUT"])
        # Store the args
        self.__dict__.update(locals())
        self.__dict__["NOverlays"] = self.NOverlays

    def Initialise(self):
        print '# NDOverlayConfigure(portName, queueSize, '\
            'blockingCallbacks, NDArrayPort, NDArrayAddr, NOverlays, ' \
            'maxBuffers, maxMemory)'
        print 'NDOverlayConfigure("%(PORT)s", %(QUEUE)d, ' \
            '%(BLOCK)d, "%(NDARRAY_PORT)s", %(NDARRAY_ADDR)s, %(NOverlays)d, ' \
            '%(BUFFERS)d, %(MEMORY)d)' % self.__dict__

    # __init__ arguments
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _NDOverlay.ArgInfo + _NDPluginProducerBase.ArgInfo

#############################

class _NDColorConvert(AutoSubstitution):
    """Template containing the records for an NDColorConvert"""
    TemplateFile = 'NDColorConvert.template'

class NDColorConvert(_NDPluginProducerBase):
    """This plugin converts arrays from one colour type to another, e.g.
    Bayer -> RGB1"""
    _SpecificTemplate = _NDColorConvert
    # NOTE: _NDPluginProducerBase comes 2nd so we overwrite NDARRAY_PORT argInfo
    ArgInfo = _SpecificTemplate.ArgInfo + _NDPluginProducerBase.ArgInfo

##############################

class NDAttributes(Device):
    """Add an attribute to the NDAttributes file for a particular ADDriver or
    NDPlugin, and associate it with the NDAttributes file"""

    _xmlfiles = {}
    done = False

    def __init__(self, port, source, name = None, attrname = None, type = "EPICS_PV", dbrtype = "DBR_NATIVE", datatype = "INT", description = "", addr = 0):
        self.__super.__init__()
        if port.DeviceName() not in self._xmlfiles:
            # write the tables to disk
            impl = xml.dom.minidom.getDOMImplementation()
            doc = impl.createDocument(None, 'Attributes', None)            
            doc.port = port
            doc.ds = IocDataStream(port.DeviceName() + ".xml")
            self._xmlfiles[port.DeviceName()] = doc            
        else:
            doc = self._xmlfiles[port.DeviceName()]
        if attrname is None:
            attrname = "%s.%s" % (port.DeviceName(), source)
        el = doc.createElement("Attribute")
        doc.documentElement.appendChild(el)
        d = dict(name=attrname, type=type, source=source, description=description)
        if type == "EPICS_PV":
            d["dbrtype"] = dbrtype
        else:
            d["datatype"] = datatype
            d["addr"] = addr
        for k,v in d.items():
            el.setAttribute(k, str(v))            

    def PostIocInitialise(self):
        if not NDAttributes.done:
            for doc in self._xmlfiles.values():                
                doc.ds.write(doc.toprettyxml())
                print "dbpf %s%sNDAttributesFile, %s/%s.xml" % (doc.port.args["P"],
                        doc.port.args["R"], doc.ds.GetDataPath(), doc.port.DeviceName())
            NDAttributes.done = True

    ArgInfo = makeArgInfo(__init__,
        name = Simple("Object name. You do not need to specify this"),
        attrname = Simple("Name of the attribute. If you leave this blank it defaults to <source>"),
        port = Ident("ADDriver or NDPlugin to attach xml file to", _ADBase),
        source = Simple("The EPICS PV (if type=EPICS_PV) or attribute name (if type=PARAM)"),
        type = Choice("Where the data should be picked up from", ["EPICS_PV", "PARAM"]),
        dbrtype = Choice("DBR type (only used if type=EPICS_PV)", ["DBR_CHAR", "DBR_SHORT", "DBR_ENUM", "DBR_INT", "DBR_LONG", "DBR_FLOAT", "DBR_STRING", "DBR_NATIVE"]),
        datatype = Choice("Data type (only used if type=PARAM)", ["INT", "DOUBLE", "STRING"]),
        description = Simple("Description of the attribute"),
        addr = Simple("Asyn address of the parameter (only used if type=PARAM)", int))
